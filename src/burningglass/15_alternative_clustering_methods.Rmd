---
title: "15_alternative_clustering_methods"
author: "Joanna Schroeder"
date: "9/4/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)
for (pkg in c("tidyverse",  "data.table", "R.utils", "maditr", "stringr", "stringi", "dplyr", "ggplot2", "lubridate", "gt", "DataExplorer", "TraMineR", "TraMineRextras", "cluster", "tools", "WeightedCluster")) {
  library(pkg, character.only = TRUE)
}

uva_color_palette <- 
c("#232D4B", #space cadet
  "#2C4F6B", #indigo dye
  "#0E879C", #blue munsell
  "#60999A", #cadet blue
  "#D1E0BF", #tea green
  "#D9E12B", #pear
  "#E6CE3A", #citrine
  "#E6A01D", #marigold
  "#E57200" #princeton orange
)
```

## Literature Review

Le Goix, R., Giraud, T., Cura, R., Le Corre, T. & Migozzi, J. (2019), "Who sells to whom in the suburbs? Home price inflation and the dynamics of sellers and buyers in the metropolitan region of Paris, 1996-2012", PLoS ONE. Vol. 14(3). e0213169.
- Ward's clustering

Mas, J.-F., Nogueira de Vasconcelos, R. & Franca-Rocha, W. (2019), "Analysis of High Temporal Resolution Land Use/Land Cover Trajectories", Land. Vol. 8(2), pp. 30.

- Implements four different distance metrics: LCS, LSP, OM transition rates, and OM features
- Ward's method for each dissimilarity index

Kim, K. (2018), "Recent Advances in Activity-Based Travel Demand Models for Greater Flexibility". Portland State University PDXScholar. PhD Thesis, Portland, 2018.
- No clustering

Riekhoff, A.-J. (2018), "Extended working lives and late-career destabilisation: A longitudinal study of Finnish register data", Advances in Life Course Research. Vol. 35, pp. 114-125.
- OM and Hamming for dissimiliary
- Ward's clustering

Struffolino, E. & Mortelmans, D. (2018), "Lone Mothers in Belgium: Labor Force Attachment and Risk Factors", In Bernardi, L. & Mortelmans, D. (eds) Lone Parenthood in the Life Course. Series: Life Course Research and Social Policies. Volume 8. Cham: Springer.
- Hamming (higher sensitiveity to small time changes)
- PAM clustering

## Approach
Multiple dissimilarity metrics and clustering methods should be used to explore the optimal outcome. 

* Our OM ("weighted")
  + Uses substitution costs based normalized transition rates in our dataset, created from observed probabilities of transition from one state to another exluding transitions to the same state ("Job to job transition")
* OM transition ("unweighted")
  + Uses substitution costs based on raw transition rates in our dataset, created from observed probabilities of transition from one state to another ("Year to year transition")
* Hamming
  + Dissimilarity based on common attributes - simple hamming, or the number of positions at which two sequences of equal length differ.
* LCS
  + Dissimilarity based on common attributes - Longest common subsequence. 
* LCP
  + Dissimilarity based on common attributes - Longest common prefix. (We can also compute based on the longest common suffix)

* Ward's
  + Hierarchical clustering, minimizes median distances between groups.
* PAM
  + Direct partitioning, faster, number of clusters set before. 
* Divisive analysis (diana)
  +

Use a sample of around 2,000 for testing for performance

/ More research necessary on why each of these decisions is methodologically sound and makes sense with our dataset and goals (not very well explained in every paper)
```{r create-sequence-objects, echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE}
# Import veteran job data ------
bg_vet_job <-read_csv("~/git/DSPG2020/career/data/04_bg_vet_job.csv")%>%
  mutate(year_enter_job_market = year(date_enter_job_market))%>%
  select(-noofjobs, -sector, -tenure) %>%
  group_by(id) %>%
  mutate(years_in_job_market = max(end_year) - (min(start_year)))

# What date did each veterans end their last ONET 55 job? (Date of military exit) ----
vet_endmilitary <- bg_vet_job%>%
  mutate(date_end_onet55 = if_else(is_onet55==T, enddate, as.Date(NA)))%>%
  filter(!is.na(date_end_onet55))%>%  #exluce people who don't have valid onet55 code
  select(id, date_end_onet55) %>%
  #keep the latest onet55 job
  group_by(id)%>%   
  arrange(desc(date_end_onet55))%>%
  group_by(id)%>%
  distinct(id, .keep_all = TRUE) 

# Join data together ------
bg_vet_job  <- inner_join(bg_vet_job, vet_endmilitary, by = "id")

# Prepare the data for sequence format ------
bg_vet_job_seq <- bg_vet_job %>%
  select(id, end_year, onet_job_zone, startdate, enddate, job_duration_day, date_end_onet55, year_enter_job_market, years_in_job_market) %>%
  mutate(year_end_onet55 = year(date_end_onet55)) %>%
  select(-year_enter_job_market) %>%
# Find jobs that came after the date ended onet55 job (Veteran career)
  filter(startdate >= date_end_onet55)%>% 
# Filter out 55 jobs that have the same start and end date  
  filter(onet_job_zone != 55)  %>%  
  mutate(start_year = year(startdate))

# Perform check ------
#check <- bg_vet_job_seq%>%
#  mutate(year_until_first_job = start_year- year_end_onet55)%>%
#  group_by(id)%>%
#  summarize(years = min(year_until_first_job))

#ggplot(check, aes(x = years)) + 
#  geom_histogram(binwidth = 1.4) + 
#  labs(title = "", x = "years until first job") 

#summary(check$years)

# Add variables, align sequences -----------
bg_vet_job_seq <- bg_vet_job_seq %>%
  mutate(years_after_onet55 = max(end_year) - year_end_onet55) %>%
  mutate(start_year = start_year - year_end_onet55 + 1)%>%  #transform from calender year to year start sequence analysis
  mutate(end_year = end_year - year_end_onet55 + 1) %>% #transform from calender year to year start sequence analysis
  select(id, start_year, end_year, onet_job_zone, year_end_onet55, years_after_onet55)%>%
  group_by(id)%>%
  arrange(desc(onet_job_zone))%>%
  group_by(id)%>%
  distinct(id, start_year, end_year, .keep_all = TRUE)
```
```{r create-sequence-object}
# Testing using ten year veteran civilian career subset
career_sequence <- function(name = "sts_vet_ten", years) {
sts_vet <- bg_vet_job_seq %>%
  filter(years_after_onet55 >= years) %>%
  select(-years_after_onet55)

sts_vet <- as.matrix(sts_vet)
sts_vet <- as.data.frame(sts_vet)
  
sts_vet <- seqformat(sts_vet, from = "SPELL", to = "STS",
            id = "id",  begin = "start_year", end = "end_year", 
            status = "onet_job_zone", process = FALSE)

vet.seq <- seqdef(sts_vet, left="Military transition unemployment", gaps="Civilian unemployment", right="DEL", cpal = c("#CBBEB5",  uva_color_palette[1], uva_color_palette[2],uva_color_palette[4],  uva_color_palette[6], uva_color_palette[9], "#CBBEB5", "#CBBEB5"))

# Filter out veterans who do not have a complete career in time period of interest
sts_vet <- vet.seq[, 1:years]

assign(name, sts_vet, envir = .GlobalEnv)
}

career_sequence("sts_vet_ten", 10)
```

```{r dissimilarity-metrics}
# Our OM (weighted transition)------
transition_matrix <- seqtrate(sts_vet_ten, weighted=FALSE, count=TRUE)
round(transition_matrix,2)
diag(transition_matrix) = 0
round(transition_matrix,2)
rowsum <- apply(transition_matrix, 1, sum)
for(i in 1:nrow(transition_matrix)) {
  for (j in 1:ncol(transition_matrix)){
    transition_matrix[i,j] = transition_matrix[i,j]/rowsum[i]
  }
}
for(j in 1:ncol(transition_matrix)){
      transition_matrix[8,j] = transition_matrix[8,j] = 0
}
transition_matrix <- round(transition_matrix,2)
cost_matrix <- 2-transition_matrix
round(cost_matrix,2)
diag(cost_matrix) = 0
cost_matrix <- round(cost_matrix,2)
weighted <- seqdist(sts_vet_ten, method = "OM", indel = "auto", sm = cost_matrix, with.missing = TRUE)

# OM unweighted transition transition --------
costs.tr <- seqcost(sts_vet_ten, method = "TRATE",with.missing = FALSE)
print(costs.tr)
unweighted <- seqdist(sts_vet_ten, method = "OM",indel = costs.tr$indel, sm = costs.tr$sm,with.missing = F)

# Hamming -------
hamming <- seqdist(sts_vet_ten, method = "HAM")

# LCS --------
lcs <- seqdist(sts_vet_ten, method = "LCS")

# LSP---------
lcp <- seqdist(sts_vet_ten, method = "LCP") 

```

```{r wards-clustering, fig.height=10}
# Our OM 
ward.weighted <- agnes(weighted, diss = TRUE, method = "ward")
plot(ward.weighted, which.plot = 2)
ward.weighted.8 <- cutree(ward.weighted, k = 8)
ward.weighted.8.fac <- factor(ward.weighted.8, labels = paste("Type", 1:8))

# OM transition
ward.unweighted <- agnes(unweighted, diss = TRUE, method = "ward")
plot(ward.unweighted, which.plot = 2)
ward.unweighted.8 <- cutree(ward.unweighted, k = 8)
ward.unweighted.8.fac <- factor(ward.unweighted.8, labels = paste("Type", 1:8))

# Hamming
ward.hamming <- agnes(hamming, diss = TRUE, method = "ward")
plot(ward.hamming, which.plot = 2)
ward.hamming.8 <- cutree(ward.hamming, k = 8)
ward.hamming.8.fac <- factor(ward.hamming.8, labels = paste("Type", 1:8))

# LCS
ward.lcs <- agnes(lcs, diss = TRUE, method = "ward")
plot(ward.lcs, which.plot = 2)
ward.lcs.8 <- cutree(ward.lcs, k = 8)
ward.lcs.8.fac <- factor(ward.lcs.8, labels = paste("Type", 1:8))

# LSP
ward.lcp <- agnes(lcp, diss = TRUE, method = "ward")
plot(ward.lcp, which.plot = 2)
ward.lcp.8 <- cutree(ward.lcp, k = 8)
ward.lcp.8.fac <- factor(ward.lcp.8, labels = paste("Type", 1:8))

#weighted
ward.weighted.plot <- seqIplot(sts_vet_ten, group = ward.weighted.8.fac)
#unweighted
ward.unweighted.plot <- seqIplot(sts_vet_ten, group = ward.unweighted.8.fac)
#hamming
ward.hamming.plot <- seqIplot(sts_vet_ten, group = ward.hamming.8.fac)
#lcs
ward.lcs.plot <- seqIplot(sts_vet_ten, group = ward.lcs.8.fac)
#lcp
ward.lcp.plot <- seqIplot(sts_vet_ten, group = ward.lcp.8.fac)
```

```{r PAM-clustering, fig.height=10}
library(WeightedCluster)

# weighted --------------
pam.weighted <- wcKMedoids(weighted, k = 8)
pam.weighted.8 <- pam.weighted$clustering
# unweighted ------------
pam.unweighted <- wcKMedoids(unweighted, k = 8)
pam.unweighted.8 <- pam.unweighted$clustering
# Hamming --------------
pam.hamming <- wcKMedoids(hamming, k = 8)
pam.hamming.8 <- pam.hamming$clustering
# LCS ---------------
pam.lcs <- wcKMedoids(lcs, k = 8)
pam.lcs.8 <- pam.lcs$clustering
# LCP --------------
pam.lcp <- wcKMedoids(lcp, k = 8)
pam.lcp.8 <- pam.lcp$clustering

par(mfrow=c(1,1))
par(mar=c(1,1,1,1))

#weighted
ward.weighted.plot <- seqIplot(sts_vet_ten, group = pam.weighted.8)
#unweighted
ward.unweighted.plot <- seqIplot(sts_vet_ten, group = pam.unweighted.8)
#hamming
ward.hamming.plot <- seqIplot(sts_vet_ten, group = pam.hamming.8)
#lcs
ward.lcs.plot <- seqIplot(sts_vet_ten, group = pam.lcs.8)
#lcp
ward.lcp.plot <- seqIplot(sts_vet_ten, group = pam.lcp.8)
```

