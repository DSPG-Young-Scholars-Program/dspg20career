---
title: "06_prepare_sequence_analysis"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
```{r}
for (pkg in c("tidyverse",  "data.table", "R.utils", "maditr", "stringr", "stringi", "dplyr", "ggplot2", "lubridate", "gt", "DataExplorer", "TraMineR", "TraMineRextras")) {
  library(pkg, character.only = TRUE)
}
#double check your working directory
# source("~/git/dspg20career/src/burningglass/03_clean_bgt.R", echo = T, prompt.echo = "", spaced = F)
bg_cleaned <- clean_bg(job = job, ed = ed, pers = pers, onet = onet)
bg_all_demographic <- as.data.table(bg_cleaned$bg_all_demographic)
bg_vet_demographic <- as.data.table(bg_cleaned$bg_vet_demographic)
bg_all_job <- as.data.table(bg_cleaned$bg_all_job)
bg_vet_job <- as.data.table(bg_cleaned$bg_vet_job)

# write.csv(bg_all_demographic, file= "data/01_bg_all_demographic.csv", row.names = F)
# write.csv(bg_vet_demographic, file= "data/02_bg_vet_demographic.csv", row.names = F)
# write.csv(bg_all_job, file= "data/03_bg_all_job.csv", row.names = F)
# write.csv(bg_vet_job, file= "data/04_bg_vet_job.csv", row.names = F)
# 
# bg_all_job <- read.csv("data/04_bg_all_job.csv")
# bg_vet_job <- read.csv("data/05_bg_vet_job.csv")

```


```{r}
# reconnecting to the database 
# conn <- dbConnect(drv = PostgreSQL(), 
#                   dbname = "sdad", 
#                   host = "10.250.124.195", 
#                   port = 5432, 
#                   user = Sys.getenv("db_userid"), 
#                   password = Sys.getenv("db_pwd"))
# # writing the new city_clean_finall table to postgis_2
# dbWriteTable(conn, c("bg", "bg_job_dc"), city_clean_final, row.names=F)
# # disconnect from postgresql database  
# dbDisconnect(conn)
```


```{r}
#select a subset of bg_all_job
set.seed(1)
id <- as.vector(bg_all_demographic$id)
sample_id <-  sample(id, size = 100)
bg_all_job_sample <- bg_all_job%>%
  filter(id %in% sample_id)
```

```{r}
#dataframe of sample id and veteran indicator
vet_id <- bg_all_demographic%>%
  select(id, veteran)
```


```{r}
table(bg_all_job$start_year)
class(bg_all_job$jobposition)

# first_job <- bg_all_job%>%
#   group_by(id)%>%
#   mutate(max_jobposition = max(jobposition, na.rm=T),  #identify the job that has the maximum of job position, indicates that it's the first job
#          match = if_else(jobposition == max_jobposition, T, F)
#         # today = as.Date("2019-01-01")
#         # days_in_job_market = today - startdate,
#         # days_employed = sum(job_duration_day),
#         # days_unemployed = days_in_job_market-days_employed
#          )%>%
#   filter(max_jobposition >0)%>%
#   filter(match == T)%>%
#   select(id, start_year)%>%
#   rename(first_job_start_year = start_year)

 # last_job <- bg_all_job%>%
 #  group_by(id)%>%
 #  mutate(min_jobposition = min(jobposition, na.rm=T), match = if_else(jobposition == min_jobposition, T, F))%>%
 #  filter(min_jobposition >0)%>%
 #  filter(match == T) %>%
 #  mutate(more_than_one_year_out = if_else(end_year <= 2017, T, F))%>%
 #  select(id, end_year, more_than_one_year_out, noofjobs, onet_job_zone)%>%
 #  rename(last_job_end_year = end_year)

# first_last_job <- first_job %>%
#   left_join(last_job, by = "id")%>%
#    left_join(vet_id, by = "id")%>%
#   mutate(first_job_start_cat = if_else(first_job_start_year < 2000, "before 2000 \n (Seniors)", if_else(first_job_start_year < 2010, "2000-2010 \n (Middle-Aged)", "2010 and later \n (Young Professional)")))%>%
#   mutate(time_in_job_market = 2018- first_job_start_year)

#table(first_last_job$first_job_start_cat)
#table(duplicated(first_last_job$id)) #check duplicates
#table(first_last_job$more_than_one_year_out)
```


#number of jobs
```{r}
first_last_job$first_job_start_cat <- factor(first_last_job$first_job_start_cat, levels = c("2010 and later \n (Young Professional)","2000-2010 \n (Middle-Aged)", "before 2000 \n (Seniors)"))

ggplot(first_last_job, aes(x=first_job_start_cat, y=noofjobs, fill = veteran)) + 
  geom_boxplot(outlier.size = 0.1)+
  coord_flip()+
  scale_fill_manual(values=c(uva_color_palette[2], uva_color_palette[8]),  guide = guide_legend(reverse = T))+
   labs(fill="veteran", y = "number of jobs", x="time entering job market")+
  theme_classic() +
    theme(axis.text.y = element_text(size=15),
          axis.title.x= element_text(size=15),
          axis.title.y= element_text(size=15))

```

# Veteran, job zone change
not using date
```{r}
bg_vet_job_change_short <- bg_vet_job%>%
  group_by(id)%>%
  mutate(ttl = n(), job_position = seq.int(ttl))%>%
 select(id, job_position, onet_job_zone)%>%
  spread("job_position", "onet_job_zone")

#write.csv(bg_vet_job_change_short, file= "data/01_sequence.csv")
vet_more_than_one_job <- bg_vet_job_change_short%>%
  filter(!is.na(`2`))
```


#Identify overlapping jobs
## 1. two or more jobs start and end in the same year
```{r}
df <- tibble(id = c(1,1,1,1),
               start = c(2000,2001,2005,2005),
               end = c(2001, 2002, 2006,2006),
               jobzone = c(1,2,3,4))
df %>%
  arrange(desc(jobzone))%>%
  distinct(start, end, .keep_all = FALSE)


bg_vet_job_seq <- bg_vet_job %>%
  mutate(startyear = year(startdate), endyear = year(enddate)) %>%
  select("id", "startyear", "endyear", "onet_job_zone")%>%
  group_by(id)%>%
  arrange(desc(onet_job_zone))%>%
  group_by(id)%>%
  distinct(id,startyear, endyear, .keep_all = TRUE)
```

```{r}
bg_vet_job_seq <- bg_vet_job %>%
  mutate(startyear = year(startdate), endyear = year(enddate)) %>%
  select("id", "startyear", "endyear", "onet_job_zone")


bg_vet_job_first <- bg_vet_job %>%
  select("id", "startdate") %>% 
  group_by(id) %>% 
  transmute(enter = year(min(startdate))) %>% 
  distinct() %>% 
  ungroup()


sts.vet <- seqformat(bg_vet_job_seq, from = "SPELL", to = "STS",
                     id = "id",  begin = "startyear", end = "endyear",
                     status = "onet_job_zone",  process = TRUE)

test <- seqdef(bg_vet_job_seq, from = "SPELL", to = "STS",
               id = "id",  begin = "startyear", end = "endyear",
               status = "onet_job_zone",  process = TRUE, states = events)
```
