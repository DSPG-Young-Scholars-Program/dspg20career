---
title: "15b_alternative_cluster_tests.Rmd"
author: "Joanna Schroeder"
date: "9/11/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)
for (pkg in c("tidyverse",  "data.table", "R.utils", "maditr", "stringr", "stringi", "dplyr", "ggplot2", "lubridate", "gt", "DataExplorer", "TraMineR", "TraMineRextras", "cluster", "tools", "WeightedCluster")) {
  library(pkg, character.only = TRUE)
}

uva_color_palette <- 
c("#232D4B", #space cadet
  "#2C4F6B", #indigo dye
  "#0E879C", #blue munsell
  "#60999A", #cadet blue
  "#D1E0BF", #tea green
  "#D9E12B", #pear
  "#E6CE3A", #citrine
  "#E6A01D", #marigold
  "#E57200" #princeton orange
)
```

How does time to run Ward's vs PAM clustering differ with scale?
2. Implementing clustering

We will test this using sequence objects with 1,000, 2,000, and 4,000 members. 

## Create sequence objects
```{r}
set.seed(09112020)

sts_nonvet <- read.csv("~/git/DSPG2020/career/data/sts_all_ten.csv", row.names = 1)

small <- sts_nonvet[sample(nrow(sts_nonvet), 1000, replace = FALSE, prob = NULL),]
medium <- sts_nonvet[sample(nrow(sts_nonvet), 2000, replace = FALSE, prob = NULL),]
large <- sts_nonvet[sample(nrow(sts_nonvet), 4000, replace = FALSE, prob = NULL),]

small <- seqdef(small, left="DEL", gaps="Civilian unemployment", right="DEL", cpal = c("#CBBEB5",  uva_color_palette[1], uva_color_palette[2],uva_color_palette[4],  uva_color_palette[6], uva_color_palette[9], "#CBBEB5"))

medium <- seqdef(medium, left="DEL", gaps="Civilian unemployment", right="DEL", cpal = c("#CBBEB5",  uva_color_palette[1], uva_color_palette[2],uva_color_palette[4],  uva_color_palette[6], uva_color_palette[9], "#CBBEB5"))

large <- seqdef(large, left="DEL", gaps="Civilian unemployment", right="DEL", cpal = c("#CBBEB5",  uva_color_palette[1], uva_color_palette[2],uva_color_palette[4],  uva_color_palette[6], uva_color_palette[9], "#CBBEB5"))
```


## 2,000 member clustering

```{r}

reps = 1:10
diss <- seqdist(small, method = "OM", indel = 1, sm = "TRATE", with.missing = TRUE, norm = TRUE)

cluster_times <- for(rep in reps) {
rep = as.character(rep)

# Ward's clustering
start_w <- Sys.time()
clusterward <- agnes(diss, diss = TRUE, method = "ward")
end_w <- Sys.time()
assign(paste0("w_run_", rep), (end_w - start_w), envir = .GlobalEnv)

# PAM clustering
start_p <- Sys.time()
clusterpam <- wcKMedoids(diss, k = 8)
end_p <- Sys.time()
assign(paste0("p_run_", rep), (end_p - start_p), envir = .GlobalEnv)
}

small_w_time <- mean.difftime((w_run_1 + w_run_2 + w_run_3 + w_run_4 + w_run_5 + w_run_6 + w_run_7 + w_run_8 + w_run_9 + w_run_10)/10)

small_p_time <- mean.difftime((p_run_1 + p_run_2 + p_run_3 + p_run_4 + p_run_5 + p_run_6 + p_run_7 + p_run_8 + p_run_9 + p_run_10)/10)

small_w_time
small_p_time
```

## 4,000 member clustering
```{r}
# Normal clustering

reps = 1:5
diss <- seqdist(medium, method = "OM", indel = 1, sm = "TRATE", with.missing = TRUE, norm = TRUE)

cluster_times <- for(rep in reps) {
rep = as.character(rep)

# Ward's cluster
start_w <- Sys.time()
clusterward <- agnes(diss, diss = TRUE, method = "ward")
end_w <- Sys.time()
assign(paste0("w_run_", rep), (end_w - start_w), envir = .GlobalEnv)

# PAM cluster
start_p <- Sys.time()
clusterpam <- wcKMedoids(diss, k = 8)
end_p <- Sys.time()
assign(paste0("p_run_", rep), (end_p - start_p), envir = .GlobalEnv)
}

medium_w_time <- mean.difftime((w_run_1 + w_run_2 + w_run_3 + w_run_4 + w_run_5)/5)

medium_p_time <- mean.difftime((p_run_1 + p_run_2 + p_run_3 + p_run_4 + p_run_5)/5)

medium_w_time
medium_p_time
```


## 4,000 member clustering
```{r}
# Normal clustering

reps = 3
diss <- seqdist(large, method = "OM", indel = 1, sm = "TRATE", with.missing = TRUE, norm = TRUE)

cluster_times <- for (rep in reps) {
rep = as.character(rep)
  
start_w <- Sys.time()
clusterward <- agnes(diss, diss = TRUE, method = "ward")
end_w <- Sys.time()
assign(paste0("w_run_", rep), (end_w - start_w), envir = .GlobalEnv)

# Weighted clustering
start_p <- Sys.time()
clusterpam <- wcKMedoids(diss, k = 8)
end_p <- Sys.time()
assign(paste0("p_run_", rep), (end_p - start_p), envir = .GlobalEnv)

assign("clusterward", clusterward, envir = .GlobalEnv)
assign("clusterpam", clusterpam, envir = .GlobalEnv)
}

large_w_time <- mean.difftime((w_run_1 + w_run_2 + w_run_3)/3)

large_p_time <- mean.difftime((p_run_1 + w_run_2 + p_run_3)/3)

large_w_time
large_p_time
```

## Time table
```{r}
times <- tibble("type" = c("unweighted", "weighted"),
                "1000" = c(small_w_time, small_p_time),
                "2000" = c(medium_w_time, medium_p_time),
                "4000" = c(large_w_time, large_p_time))

times
```

# Cluster differences
```{r fig.height=5, fig.width=15}
#plot(clusterward_n, which.plot = 2)
clusterward_8 <- cutree(clusterward, k = 8)
clusterward_8_fac <- factor(clusterward_8, labels = paste("Type", 1:8))

clusterpam_8 <- clusterpam$clustering
clusterpam_8_fac <- factor(clusterpam_8, labels = paste("Type", 1:8))

clusterpam_8_fac <- factor(clusterpam_8_fac, levels = c("Type 2", "Type 8", "Type 3", "Type 7", "Type 4", "Type 5", "Type 1", "Type 6"))

par(mfrow=c(1,3))
w_plot <- seqIplot(large[,1:30], group = clusterward_8_fac, border = NA, use.layout = TRUE, cols = 8, withlegend = F, sortv = "from.start", main = "wards")
p_plot <- seqIplot(large[,1:30], group = clusterpam_8_fac, border = NA, use.layout = TRUE, cols = 8, withlegend = F, sortv = "from.start", main = "pam")
seqlegend(large)

as.data.frame(clusterward_8_fac) %>%
  group_by(clusterward_8_fac) %>% summarise(n = n())

as.data.frame(clusterpam_8_fac) %>%
  group_by(clusterpam_8_fac) %>% summarise(n = n()) 
```

Overall clusters look pretty similar. The biggest differences are the Ward's solution has two unemployment clusters. The PAM solution has a career mobility cluster (Type 3).

Surprisingly, the PAM cluster solution has a more even distribution (523 range) than the Ward's (885 range) solution. 


```{r fig.height=5, fig.width=15}
properties <- c("state", "spell.age", "spell.dur", "duration", "pattern", "AFpattern", "transition", "AFtransition", "Complexity")

for (property in properties) {
start_prop <- Sys.time()
clusterprop <- seqpropclust(large, diss = diss, properties = property, maxcluster = 8)
end_prop <- Sys.time()

clusterprop_8 <- clusterprop$fitted
clusterprop_10_fac <- factor(clusterprop_8$`(fitted)`, labels = paste("Type", 1:8))

prop_plot <- seqIplot(large[,1:30], group = clusterprop_10_fac, border = NA, use.layout = TRUE, cols = 8, withlegend = F, sortv = "from.start", main = property)

assign(paste0("prop_run_", property), (end_prop - start_prop), envir = .GlobalEnv)
assign(property, prop_plot, envir = .GlobalEnv)
}

prop_run_state
prop_run_spell.age
prop_run_spell.dur
prop_run_duration
prop_run_pattern
prop_run_AFpattern
prop_run_transition
prop_run_AFtransition
prop_run_Complexity

prop_time <- mean.difftime((prop_run_state + prop_run_spell.age + prop_run_spell.dur + prop_run_duration + prop_run_pattern + prop_run_AFpattern + prop_run_transition + prop_run_AFtransition + prop_run_Complexity)/9)

prop_time

```


state: The state in which an individual is found, at each time position t
Clustered by state in early, mid, and late career. Clusters 1 and 2 are Zone 4 early career, Cluster 3 is Zone 4 mid career. Cluster 4 is Zone 3 early career. Cluster 5 is Zone 3 mid career. Cluster 6 is Zone 2 mid career. Cluster 7 is zone 5 mid career. Cluster 8 is missing/unemployed mid career.
Pretty similar to PAM and Wards Solutions

spell.age: The age at the beginning of each spell of a given type
I think these are emphasizing the relationships between subsequence or two states. Type 1 is Zone 4 and Zone 3, Type 2 is Zone 4 and Unemployment/Missing, Type 3 is Zone 4 and Zone 2, Type 4 is Zone 4 and Zone 5, Type 5 is Zone 3 and Zone 2, Type 8 is Zone 5 and unemployment/missing.


spell.dur: The duration of each of the spells presented above
duration: The total time spent in each state
These look pretty similar, though you can see how duration slightly preferences single state durations whereas spell.dur preferences subsequence durations

pattern: Count of the frequent subsequences of states in the distinct successive states
AFpattern: Age at the first occurrence of the above frequent subsequence
Pretty similar

transition: Count of the frequent subsequence of events in each sequence, where each transition is considered another event
AFtransition: Age at the first occurrence of the above frequent subsequence
These look pretty similar but the most different of AF pairs.


Complexity: Complexity index, number of transitions, turbulence
These are interesting though maybe not as useful as others. I think Type 3 is really interesting, with a mid-career zone change, back to the original zone. I wonder if this may be more useful with less clusters.