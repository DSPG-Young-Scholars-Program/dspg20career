---
title: "Sequence Clustering"
description: "Clustering post-military veteran career sequences and exploring these results"
weight: 4
draft: false
output: html_document
editor_options: 
  chunk_output_type: console
---
 

```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
knitr::opts_chunk$set(error = TRUE)

for (pkg in c("tidyverse",  "data.table", "R.utils", "maditr", "stringr", "stringi", "dplyr", "ggplot2", "lubridate", "gt", "DataExplorer", "TraMineR", "TraMineRextras", "cluster", "tools")) {
  library(pkg, character.only = TRUE)
}
uva_color_palette <- 
c("#232D4B", #space cadet
  "#2C4F6B", #indigo dye
  "#0E879C", #blue munsell
  "#60999A", #cadet blue
  "#D1E0BF", #tea green
  "#D9E12B", #pear
  "#E6CE3A", #citrine
  "#E6A01D", #marigold
  "#E57200" #princeton orange
)

#import function to clean the job data to identify post military jobs
source("~/git/dspg20career/src/burningglass/clean_post_military_job.R", echo = T, prompt.echo = "", spaced = F)
 
#read in vet job data
bg_vet_job <-read_csv("~/git/dspg20career/data/04_bg_vet_job.csv")
 
#perform the cleaning function
bg_vet_job_seq <- clean_post_military(bg_vet_job)

bg_vet_job_seq <- as.matrix(bg_vet_job_seq)
bg_vet_job_seq <- as.data.frame(bg_vet_job_seq)

# Convert sequence data from SPELL format to STS format
sts_vet <- seqformat(bg_vet_job_seq, from = "SPELL", to = "STS",
                     id = "id",  begin = "start_year", end = "end_year", 
                     status = "onet_job_zone", process = FALSE)

#obtain jobs that appear after 10 years they exit military 
sts_vet <- sts_vet[, 1:10]

# Here we are renaming columns to be in format "yn" (year in the job market)
names(sts_vet) <- paste0("y", 1:ncol(sts_vet))
```

### Transition Matrix
```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
#create sequence object
#assign left NA as transitional unemployment, gaps as unemployment, and right NA as unemployment or exit
#assign colors to different categories

vet.seq <- seqdef(sts_vet, 
                  left="Military Transitional Unemployment", gaps="Civilian Unemployment", right="Retirement", 
                  cpal = c("#CBBEB5",  uva_color_palette[1], uva_color_palette[2],uva_color_palette[4],  uva_color_palette[6], uva_color_palette[9], "#CBBEB5", "#CBBEB5","#CBBEB5")
                  )

# Compute transition matrix (no standardization)
transition_matrix <- seqtrate(vet.seq)
cost_matrix <- seqsubm(vet.seq, method = "TRATE")

# Compute transition matrix (with standardization)
transition_matrix_count <- seqtrate(vet.seq, weighted=FALSE, count=TRUE) #using count
diag(transition_matrix_count) = 0  #make the diagnal 0

#calculate rowsum
rowsum <- apply(transition_matrix_count, 1, sum)
n_stage <- dim(transition_matrix_count)[1]
#initialize a transition matrix
transition_matrix_standardize <- matrix(NA, n_stage, n_stage)

#calculate percent 
for(i in 1:n_stage) {
  for (j in 1:n_stage){
    transition_matrix_standardize[i,j] = transition_matrix_count[i,j]/rowsum[i]
  }
}

#code NAs as 0
for(j in 1:ncol(transition_matrix_standardize)){
      transition_matrix_standardize[9,j] = transition_matrix_standardize[9,j] = 0
}
#round(transition_matrix_standardize,2)

# Convert transition matrix to cost matrix
cost_matrix_standardized <- matrix(NA, n_stage, n_stage) #initiate an empty cost matrix
for (i in 1:n_stage){
  for(j in 1:n_stage){
    cost_matrix_standardized[i,j] = 2-transition_matrix_standardize[i,j]-transition_matrix_standardize[j,i]
  }
}
  
#make the diagnal 0
diag(cost_matrix_standardized) = 0
```

There are nine levels of job state: job zone (level) 1, job zone (level) 2, job zone (level) 3, job zone (level) 4, job zone (level) 5, transitional unemployment, unemployment, unemployment or retirement, and unknown job zone. 

[Here comes a table that explains the job levels.]

In our sequence analysis, we want to categorize sequential pattern of the job levels. One approach for categorizing sequences is to compute the distance between two sequences. For example, we have two job state sequences and each sequence is composed of three states:
$$S_1 = \{ \text{zone 1, zone 2, zone 3} \}$$
$$S_2 = \{ \text{zone 1, zone 1, zone 3} \}$$
The difference between $S_1$ and $S_2$ is at the second state where $S_1$ has zone 2 while $S_2$ has zone 1. To transform $S_1$ to $S_2$, we substitude zone 2 with zone 1 at state 2. We use the minimum number of substitution that is required to transform one sequence to another sequence to reflect the distance between these two sequences. This is known as "indels". However not all substitutions are the same: substitute zone 1 with zone 5 is way more costly than substituting with zone 2. Therefore, we use transition rate to estimate the cost to transform from one state to another state. 


We constructed transition matrix $T$ with dimension $k \times k$, k being the number of job states. The transition matrix is composed of transition rates between each pair of states. $T(i,j)$ represents the probability of a sample to convert from the current job state $i$ to the next job state $j$, for $i \in [1,9], j \in [1,9]$. Thus the sum of each row is 1. Figure 1 shows the transition matrix.

Darker the color, higher the transition probability between two states. The job states on the diagnal of the transition matrix have the darkest color, meaning that our sample has a higher probability to stay in the same job state. 

```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE, fig.width=10}
state <- c("unknown \n zone", "zone1", "zone2", "zone3", "zone4", "zone5", "military \n transitional \n unemployment \n", "civilian \n unemployment", "retirement")
#original transitional matrix 
tmatrix.df <- as.data.frame(transition_matrix)
#tmatrix.df$startState <- row.names(tmatrix.df)

colnames(tmatrix.df) <- state
tmatrix.df$startState <- state
tmatrix.df <- melt(tmatrix.df, "startState")

#colnames(tmatrix.df)[colnames(tmatrix.df) == "variable"] <- "endState"
colnames(tmatrix.df) <- c("startState", "endState", "value")                                      
ggplot(data = tmatrix.df, aes(x = endState, y = factor(startState, levels = rev(state)), fill = value)) + 
  geom_tile() +    
  geom_text(aes(label=round(value,3))) +  
  scale_x_discrete(position = "top") +  
  scale_fill_gradient(low = "white", high = "#E57200") +
  theme(legend.position="bottom", panel.background = element_blank(),        
        plot.title = element_text(face = "bold")) +  
  labs(fill = "Transition Probability",        
       title = "Year-to-Year Transition Matrix",     
       y = "Current Job",       
       x = "Next Job")+
  theme(axis.text.x = element_text(size = 9, hjust = .5, vjust = .5),
        axis.text.y = element_text(size = 9, hjust = .5, vjust = .5),  
        axis.title.x = element_text(size = 14, hjust = .5, vjust = .5),
        axis.title.y = element_text(size = 14, hjust = .5, vjust = .5),
        legend.title=element_text(size=14),
        legend.text = element_text(size=9))
```
$$\text{Fig 1. Year-to-Year Transition Matrix}$$

### Transition Matrix standardization
For sequence clustering, our next step is to construct a substitution-cost matrix $SC$ using the formula 
$$SC(i,j) = 2 -T(i,j) -T(j,i)$$

Substitution-cost matrix reflects the cost for substituting a job state with another. $SC(i,j)$ represent the cost for changing from the current job state $i$ to the next job state $j$, for $i \in [1,9], j \in [1,9]$. We then use transition rate to construct substitution-cost matrix using the formula
$$SC(i, j) = \begin{cases}
2-T(i,j)-T(j,i), & i \neq j\\
0, & i=j
\end{cases}$$

The consequence for the diagnal to have large transition probability is the consistent cost between job state $i$ and $j$ that $SC(i, j)$ will be approximately 2. In order to make the difference between two different states more visible, we standardize the transition matrix by excluding the diagnal when constructing the transition matrix. Figure 2 shows the standardized transition matrix that reflects changes between states. Having diagnal as 0, we can better observe the difference of the transition probability between two different states. 


```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE, fig.width=10}
#standardized transition matrix
tmatrix.standardize.df <- as.data.frame(transition_matrix_standardize)

colnames(tmatrix.standardize.df) <- state
tmatrix.standardize.df$startState <- state
tmatrix.standardize.df <- melt(tmatrix.standardize.df, "startState")

colnames(tmatrix.standardize.df) <- c("startState", "endState", "value")                                                                         
ggplot(data = tmatrix.standardize.df, aes(x = endState, y = factor(startState, levels = rev(state)), fill = value)) + 
  geom_tile() +    
  geom_text(aes(label=round(value,3))) +  
  scale_x_discrete(position = "top") +  
  scale_fill_gradient(low = "white", high = "#E57200") +
  theme(legend.position="bottom", panel.background = element_blank(),         
        plot.title = element_text(face = "bold")) +  
  labs(fill = "Transition Probability",        
       title = "State Transition Matrix",     
       y = "Current Job",       
       x = "Next Job")+
  theme(axis.text.x = element_text(size = 9, hjust = .5, vjust = .5),
        axis.text.y = element_text(size = 9, hjust = .5, vjust = .5),  
        axis.title.x = element_text(size = 14, hjust = .5, vjust = .5),
        axis.title.y = element_text(size = 14, hjust = .5, vjust = .5),
        legend.title=element_text(size=14),
        legend.text = element_text(size=9))
```
$$\text{Fig 2. State Transition Matrix}$$

### Clustering
We identified 5185 post-military sequences, and there are 2113 (40.8%) distinct sequences. We identified 8 types of clusterings. We have type 1, 5, 6 clusters mainly composed of veterans in job zone 4. Specifically, veterans in type 1 cluster had few years' of transitional unemployment after exiting military before their job-zone-level 4 jobs. 

![](/findings/results-section-clustering_files/Fig3.png){width=100% height=900px}
$$\text{Fig 3. Type 1 Clusters}$$


We do observe a career promotion among veterans in type 2 cluster where they started with job zone 3 and went into job zone 4.

![](/findings/results-section-clustering_files/Fig4.png){width=100% height=300px}
$$\text{Fig 4. Type 2 Clusters}$$

The remaining type 3, 7, 8 do no exibit a change in post-military career. Type 3 cluster is composed of jobs in job zone 5. Type 7 cluster is composed of jobs in job zone 1. And type 8 cluster is composed of jobs in job zone 3. 


![](/findings/results-section-clustering_files/Fig5.png) {width=100% height=760px;margin-left: 50px; margin-right:50px}


$$\text{Fig 5. Type 3 Clusters}$$


```{r fig.height=17, fig.width=8, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
# vet.seq.OM <- seqdist(vet.seq, method = "OM", indel = 3, sm = cost_matrix_standardized, with.missing = TRUE)
# clusterward <- agnes(vet.seq.OM, diss = TRUE, method = "ward")
# saveRDS(clusterward, file = "data/clusterward_onet55_10yrs_standardized_matrix.rds")

clusterward <- readRDS(file = "~/git/dspg20career/data/clusterward_onet55_10yrs_normalized_matrix.rds")

#dendrogram 
# plot(clusterward, which.plots =2)
# abline(h=200, col="purple")
# abline(h=90, col="red")
cluster8 <- cutree(clusterward, k=8)
cluster8 <- factor(cluster8, labels = c("Type 1",  "Type 2", "Type 3", "Type 4", "Type 5", "Type 6", "Type 7", "Type 8"))
table(cluster8)

#longitudinal plot
seqfplot(vet.seq, group = cluster8, pbarw = T)

#another cluster plot
seqmtplot(vet.seq, group = cluster8)
```



To understand how veterans developed different career trajectories, we investigated the relationship between gender, highest degree level and the career trajectory cluster they were associated with. 

### Do veterans' education background influence their career trajectory?

Here we are showing how many veterans with different degrees fall into each of these 8 clusters. Since the majority of our veteran sample had highest degree as bachelor's and master's degree, here we show the percentage of veterans fall into each of the eight clusters for each highest degree earned. Thus each row adds up to 1. 

![](/findings/results-section-clustering_files/Fig6.png){width=100% height=500px}
$$\text{Fig 7. Cluster Distribution for Different Levels of Education}$$

```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
bg_vet_demographic <-read_csv("~/git/dspg20career/data/02_bg_vet_demographic.csv")
vet <- unique(bg_vet_job_seq$id)
vet_df <- as.data.frame(cbind(vet, cluster8))
colnames(vet_df) <- c("id", "cluster")
vet_df <- left_join(vet_df, bg_vet_demographic, by = "id")

degree <- vet_df %>%
  filter(!is.na(degree_highest))%>%
  group_by(cluster, degree_highest)%>%
  summarize(count=n())%>%
  group_by(degree_highest)%>%
  mutate(sum = sum(count))%>%
  mutate(perc = count/sum)%>%
  filter(degree_highest != "others")%>%
  mutate(cluster = if_else(cluster == 2, 4,
                  if_else(cluster == 3, 5,
                  if_else(cluster == 4, 8,
                  if_else(cluster == 5, 2,
                  if_else(cluster == 6, 3,
                  if_else(cluster == 7, 6,
                  if_else(cluster == 8, 7, cluster))))))))

degree$cluster <- as.factor(degree$cluster)
degree$degree_highest <- factor(degree$degree_highest, levels = c("certificate","highschool", "associate", "bachelor", "master", "doctor"))
#degree$count[is.na(degree$count)] <- 0
#cluster distribution
cluster_count <- degree%>%
  group_by(cluster)%>%
  summarize(N=sum(count))

ggplot(cluster_count, aes(x = cluster, y = N, fill = N))+
  geom_bar(stat = "identity")+ 
  scale_fill_continuous(low = uva_color_palette[9], high=uva_color_palette[9])+
  theme_classic()+
  theme(axis.text.x = element_text(size = 11, hjust = .5, vjust = .5),
        axis.text.y = element_text(size = 11, hjust = .5, vjust = .5),  
        axis.title.x = element_text(size = 14, hjust = .5, vjust = .5),
        axis.title.y = element_text(size = 14, hjust = .5, vjust = .5),
        legend.title=element_text(size=13),
        legend.text = element_text(size=11))

#degree distribution
degree_count <- degree%>%
  group_by(degree_highest)%>%
  summarize(N=sum(count))

ggplot(degree_count, aes(x = degree_highest, y = N, fill = N))+
  geom_bar(stat = "identity")+ 
  scale_fill_continuous(low = uva_color_palette[9], high=uva_color_palette[9])+
  theme_classic()+
  theme(axis.text.x = element_text(size = 11, hjust = .5, vjust = .5),
        axis.text.y = element_text(size = 11, hjust = .5, vjust = .5),  
        axis.title.x = element_text(size = 14, hjust = .5, vjust = .5),
        axis.title.y = element_text(size = 14, hjust = .5, vjust = .5),
        legend.title=element_text(size=13),
        legend.text = element_text(size=11))

degree$cluster <- as.factor(degree$cluster)
degree$degree_highest <- factor(degree$degree_highest, levels = c("certificate","highschool", "associate", "bachelor", "master", "doctor"))
degree <- as.data.frame(degree)

#saved the figure to local file
ggplot(degree, aes(cluster, degree_highest, fill= perc)) +
  geom_tile()+
  scale_fill_gradient(low="white", high=uva_color_palette[9])+
  theme_classic()+
  labs(title = "Degree Distribution among Clusters", y="Highest Degree Earned", x = "Cluster")+
  guides(fill=guide_legend(title = "Percent"))+
  theme(axis.text.x = element_text(size = 11, hjust = .5, vjust = .5),
        axis.text.y = element_text(size = 11, hjust = .5, vjust = .5),
        axis.title.x = element_text(size = 14, hjust = .5, vjust = .5),
        axis.title.y = element_text(size = 14, hjust = .5, vjust = .5),
        legend.title=element_text(size=13),
        legend.text = element_text(size=11))
```


```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
# contingency table
vet <- unique(bg_vet_job_seq$id)
vet_df <- as.data.frame(cbind(vet, cluster8))
colnames(vet_df) <- c("id", "cluster")
vet_df$cluster <- as.factor(vet_df$cluster)

vet_df <- vet_df %>%
  left_join(bg_vet_demographic, by = "id")%>%
  filter(!is.na(degree_highest))

table <- table(vet_df$cluster, vet_df$degree_highest)
m<- as.data.frame(matrix(c(130, 781, 288,1745), 2, 2))
colnames(m) <- c("cluster 2", "not cluster 2")
rownames(m) <- c("bachelor's degree", "others")

m%>%
  as.data.frame()%>%
  gt(rownames_to_stub = T)%>%
  tab_header(
    title = "Two-way Frequency Table"
  )

```
$$\text{Table 1. Two-way Frequency Table}$$
```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
degree_p_matrix <- c()
for (degree in 1: ncol(table)){ 
  degree_p_vector_i <- c()
  for (i in 1:nrow(table)){ #cluster 1-8
    tb_i <- matrix(NA, nrow = 2, ncol = 2)
    tb_i[1,1] <- table[i,degree]
    tb_i[2,1] <- sum(table[,degree])-table[i,degree]
    tb_i[1,2] <- sum(table[i,])-table[i,degree]
    tb_i[2,2] <- sum(table)-tb_i[1,1] - tb_i[2,1] -tb_i[1,2] 
    degree_p_vector_i[i] <- fisher.test(tb_i)$p.value
  }
  degree_p_matrix <- cbind(degree_p_matrix, degree_p_vector_i)
}

colnames(degree_p_matrix) <- c("associate","bachelor","certificate", "doctor", "highschool", "master", "others")
degree_p_matrix <- degree_p_matrix[,c("others","certificate","highschool", "associate", "bachelor", "master", "doctor")]

state <- c("others","certificate","highschool", "associate", "bachelor", "master", "doctor")
#original transitional matrix 
degree_p_df<- as.data.frame(degree_p_matrix)
degree_p_df$cluster <- c("cluster1", "cluster2", "cluster3", "cluster4", "cluster5", "cluster6", "cluster7", "cluster8")

degree_p_df <- melt(degree_p_df, "cluster")
colnames(degree_p_df) <- c("cluster", "degree", "value")                                      
ggplot(data = degree_p_df, aes(x = cluster, y = factor(degree, levels = rev(state)), fill = value)) + 
  geom_tile() +    
  geom_text(aes(label=round(value,3))) +  
  scale_x_discrete(position = "top") +  
  scale_fill_gradient(low = "white", high = "#E57200") +
  theme(legend.position="bottom", panel.background = element_blank(),         plot.title = element_text(face = "bold")) +  
  labs(fill = "Cost value",        
       title = "P-values for Fisher's Exact Test between Cluster and Degree",     
       y = "Degree",     
       x = "Cluster")+
  theme(plot.title = element_text(size=10))

```



### Do Female and Male Veterans have different career trajectory?
In our sample, we have 15.9% (N=824) female veterans, 84.1% (N=3666) male veterans. We conducted $\chi^2$ test. Using 0.05 as the critical value, we conclude that female is statistically different from male in cluster 2 (p=0.0083), 5 (p<0.001), 6 (p=0.017), and 8 (0.042).
```{r echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
gender <- vet_df %>%
  filter(!is.na(gender))%>%
  group_by(cluster, gender)%>%
  summarize(count=n())%>%
  group_by(gender)%>%
  mutate(sum = sum(count))%>%
  mutate(perc = count/sum )

#degree$count[is.na(degree$count)] <- 0

gender$cluster <- as.factor(gender$cluster)
gender$gender <- as.factor(gender$gender)


gender <- as.data.frame(gender)
# ggplot(gender, aes(cluster, gender, fill= count)) + 
#   geom_tile()+
#   scale_fill_gradient(low="white", high="blue")+
#   theme_classic()+
#   labs(title = "Clustering X Gender --before standardization")

ggplot(gender, aes(cluster, gender, fill= perc)) + 
  geom_tile()+
  scale_fill_gradient(low="white", high="blue")+
  theme_classic()+
  labs(title = "Gender Distribution among Clusters")

# contingency table
vet <- unique(bg_vet_job_seq$id)
vet_df <- as.data.frame(cbind(vet, cluster8))
colnames(vet_df) <- c("id", "cluster")
vet_df$cluster <- as.factor(vet_df$cluster)
vet_df <- vet_df %>%
  left_join(bg_vet_demographic, by = "id")%>%
  filter(!is.na(gender))

table <- table(vet_df$cluster, vet_df$gender)
table

gender_p_vector <- c()
for (i in 1: nrow(table)){
  tb_i <- matrix(NA, nrow = 2, ncol = 2)
  tb_i[1,1] <- table[i,1]
  tb_i[2,1] <- sum(table[,1])-table[i,1]
  tb_i[1,2] <- table[i,2]
  tb_i[2,2] <- sum(table[,2])-table[i,2]
  gender_p_vector[i] <- chisq.test(tb_i)$p.value
}
gender_p_vector
gender_p_vector <= 0.05
```


### References 

[List your references here using APA format (or at least standardize all of the references using the same format).]








